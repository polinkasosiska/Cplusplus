#include <iostream>
#include <vector>
#include <algorithm>
#include <time.h>
#include <random>

using namespace std;


//функция генерирует различные подпоследовательности длины k из массива длины n
//n - общее кол-во элементов
//k - из скольки элементов нужно составить сочетания
void generate(int n, int k, vector<vector<int>>& seq, vector<int> source, int& count) {
    int* A, i, p;
    A = new int[k];
    //в массиве А у нас содержатся индексы элементов 
    //изначально 0 1 2 3 4 5
    //мы будем их менять, и соответственно, по этим индексам составлять последовательности
    //например, для длины k = 2, у нас будут следующие последовательности
    //0 1, 0 2, 0 3, 0 4, 0 5
    //далее  1 2, 1 3, 1 4, 1 5 .... 4 5, 4 6, 5 6  
    for (i = 0; i < k; i++) A[i] = i;
    while (1) {
        count++;
        vector<int> temp;
        for (i = 0; i < k; i++) {
            temp.push_back(source[A[i]]);   //здесь мы помещаем в вектор очередной элемент последовательности
            //cout << source[A[i]] << " ";   можете раскомментировать и будут выведены все полученные подпоследовательности
        }
        //cout << endl; //
        seq.push_back(temp);    //а здесь кладем очередную сгенерированную последовательность в вектор со всеми подпоследовательностями 
        if (A[k - 1] < n - 1)
            A[k - 1]++;
        else {
            for (p = k - 1; p > 0; p--)
                if (A[p] - A[p - 1] > 1) break;
            if (p == 0) break;
            A[p - 1] ++;
            for (i = p; i < k; i++) A[i] = A[i - 1] + 1;
        }
    }
    delete[] A;
}

//метод полного перебора
//составим из исходной последовательности все возможные последовательности
//и будем проверять каждую
void brutefroce_search(vector<int> a) {
    vector<vector<int>> seq;    //вектор векторов - каждый элемент вектора - это последовательность
    int n = a.size();           //длина исходной последовательности
    vector<vector<int>> seq2;   //вектор векторов, содержит строго возрастающие подпоследовательности
    int count = 0;              //счетчик кол-ва операций

    //генерируем все возможные подпоследовательности
    for (int i = 2; i <= n; i++) {
        generate(n, i, seq, a, count);
    }

    //ищем строго возрастающие подпоследовательности
    for (int i = 0; i < seq.size(); i++) {
        bool flag = true;
        for (int j = 1; j < seq[i].size(); j++) {
            count++;
            //проверяем 2 подряд идущих элемента последовательности
            //и если следующий элемент меньше либо равен текущему, то данная последовательность не строго возрастающая
            if (seq[i][j] <= seq[i][j - 1]) {
                flag = false;
                break;
            }
        }
        //если последовательность строго возрастающая
        //кладем ее в вектор со строго возрастающими последовательностями
        if (flag) seq2.push_back(seq[i]);
    }

    int k = seq2.size();
    cout << endl << "Length of sequence = " << seq2[k - 1].size();
    cout << endl << "Amount of operations = " << count;
    cout << endl;

    //выводим последний элемент вектора - это и будет самая длинная возрастающая подпоследовательность
    for (int i = 0; i < seq2[k - 1].size(); i++) {
        cout << seq2[k - 1][i] << " ";
    }
    cout << endl;
}

void dynamicprog_search(vector<int> a) {
    int n = a.size();           //размер исходной последовательности
    int* d = new int[n];    //d[i] - это длина наидлиннейшей возрастающей подпоследовательности,
                            //оканчивающейся именно в элементе с индексом i  
    int* pos = new int[n];  //вспомогательный массив для восстановления подпоследовательности,
    // индекс pos[i] будет обозначать тот самый индекс j, при котором получилось наибольшее значение d[i]
    int* prev = new int[n - 1]; //rev[i]  — позицию предыдущего элемента для a[i].
    int len = 0;    //длина наидлиннейшей подпоследовательности
    int count = 0;  //количество операций при выполнении алгоритма

    //Динамика теперь будет такой: пусть d[i] (i = 0 ... n) — это число, 
    //на которое оканчивается возрастающая подпоследовательность длины i 
    //(а если таких чисел несколько — то наименьшее из них).
    //Изначально мы полагаем d[0] = -бесконечность, а все остальные элементы d[i] = бесконечность.
    //Считать эту динамику мы будем постепенно, обработав число a[0], затем a[1], и т.д.

    pos[0] = -1;
    d[0] = -999999999;
    for (int i = 1; i < n; i++) d[i] = 999999999;

    //Заметим теперь, что у этой динамики есть одно очень важное свойство: 
    //d[i-1] <= d[i] для всех i = 1 ... n. 
    //Другое свойство — что каждый элемент a[i] обновляет максимум одну ячейку d[j].
    //Таким образом, это означает, что обрабатывать очередное 
    //a[i] мы можем за O(log n), сделав двоичный поиск по массиву d[]. 
    //В самом деле, мы просто ищем в массиве d[] первое число, 
    //которое строго больше a[i], и пытаемся произвести обновление 
    //того элемента.

    for (int i = 0; i < n; i++) {
        count++;
        //двоичный поиск
        //возвращает позицию первого элемента, строго большего данного a[i]
        int j = int(upper_bound(d, d + n, a[i]) - d);
        if (d[j - 1] < a[i] && a[i] < d[j]) {
            d[j] = a[i];
            pos[j] = i;
            prev[i] = pos[j - 1];
            len = max(len, j);
        }
    }

    // восстановление ответа
    vector<int> answer;
    int p = pos[len];
    while (p != -1) {
        answer.push_back(a[p]);
        p = prev[p];
    }
    reverse(answer.begin(), answer.end());

    cout << endl << "Length of sequence = " << answer.size();
    cout << endl << "Amount of operations = " << count;
    cout << endl;

    for (int i = 0; i < answer.size(); i++) {
        cout << answer[i] << " ";
    }

    cout << endl;

    //delete prev;
    //delete[] d;
    //delete[] pos;
}



int main()
{
    srand(time(0));
    vector<int> a;      //исходная поледовательность
    int size;
    //вводим размер исходного массива
    cout << endl << "Input size of array: ";
    cin >> size;

    //генерируем случайным образом элементы исходного массива и выводим их в консоль
    cout << endl << "Source array:" << endl;
    for (int i = 0; i < size; i++) {
        a.push_back(rand() % 100);
        cout << a[i] << " ";
    }
    cout << endl;

    brutefroce_search(a);
    dynamicprog_search(a);

    system("pause");
    return 0;
}